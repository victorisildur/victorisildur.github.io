---
layout: post
title: "TLS加密、证书"
date: 2016-10-12 08:27:00
categories: programming
excerpt: "certificate, keypair, authentication概念"
---

## 场景

https是tls最常见的使用场景，然而本篇针对的是物联下的加密，请设想一个设备要往腾讯云发送信息，
云端应如何确定这个设备是合法的，其信息是真实可靠的？

## TLS证书

考虑RSA算法，证书其实就是public key + 附加信息.
附加信息通常有：域名、email、过期时间等。

证书用来干嘛呢？譬如张三是网站站长，他希望他的网站内容完全不被劫持、篡改、监听，
所以他给客户发放自己的证书"东半球最安全网站: 张三炒股网"，并附上公钥，和一个"数字签名"。

客户拿到证书，通过公钥解密"数字签名"，客户一看，恩，这确实是张三的签名，我见过他的字。
然后才放心的上这个网站。

这就是认证(authentication)。

## 认证过程

比方打完了，有些细节问题没解决：

1. 张三的签名附在证书里，证书是大家都可见的，怎么保证坏人看不到签名长什么样？
2. 客户离张三的公司十万八千里，客户怎么见过张三的签名？

这里就是RSA算法出现的时候了，先不提欧拉定理，只要知道：

1. 公钥加密的信息，只有私钥能解
2. 私钥加密的信息，只有公钥能解

好了，客户要认证张三，需要这四步：

1. 张三把公钥放到显眼有安全的地方，所有客户都知道张三的公钥
2. 客户生成个随机字符串，用张三的公钥加密，然后发给张三
3. 张三收到密文，用自己的私钥解密出字符串，然后发回给客户
4. 客户收到字符串，和自己最开始生成的一比较，一丝不差，恩，这个确实是张三。他确实有公钥对应的私钥。

对应到真实世界，第一点很难实现，所以考虑一种实现(solution 1)：

1. 张三的证书是 公钥+网站信息，数字签名是 私钥加密后的"公钥+网站信息"的hash. 最后把 公钥+网站信息+数字签名 作为完整证书。
2. 客户连接到张三服务器时，张三把完整证书发送给客户
3. 客户拿到证书，用公钥解密数字签名，得到hash，再自己对证书的"公钥+网站信息"部分哈希一下，
两者比较下，如果一样，说明数字签名确实是正确的私钥加密的，张三确实公私钥都有。
4. 客户发送公钥加密后的随机字符串给张三，张三私钥解密后回传，字符串一致，则认证这就是张三。

solution 1的方案有致命缺陷，就是公钥私钥都是张三给的，黑客要是拦截到证书，首先把公钥替换掉，然后把"公钥+网站信息hash"用自己的私钥加密下，替换掉原来的签名。
这样客户去执行3,4步，不会发现任何问题。

这个问题产生的根本原因在于公钥私钥都是张三提供，客户啥凭据都没有，一旦通信被监听，就很容易被中间人冒充成张三了。

对此，有了solution 2:

1. 张三午饭前亲自开车到客户家，把自己的证书放到客户那里
2. 客户上网拿到证书，hash下，得到预期的加密前的数字证书，再用早上张三给的证书的公钥解密，得到加密前的数字证书。两相比较，一样说明这次上网拿到的证书确实是张三的私钥加密的（因为使用张三早上带过来的证书的公钥解密的)
3. 客户发送公钥加密后的随机字符串给这次上网的对象，对象私钥解密后回传，如果一致，则确认这是张三。

这里，张三要本人亲自去给每个客户送证书。这叫离线操作。实际中代价太大。

对此，有了solution 3:

1. 大家都能安全的见到权威CA，CA把自己的证书发给**每个人**
2. 张三亲自拜访CA，CA验证了张三的合法性后，CA用自己的私钥给张三的证书签名
3. 客户上网拿到证书，号称是张三，因为CA已经把CA证书发给了客户，客户用CA证书的公钥解密数字签名，并与预期的hash比较。若两厢一样，说明张三的证书确实是CA签名的，如果客户信任CA，也就应该相信这就是张三。
4. 客户发送张三公钥加密后的随机字符串，张三解密后回传，若一致，则确认张三身份。

实际中的https基本就是solution 3. 

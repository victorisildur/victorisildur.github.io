---
layout: post
title: "linux命令细节汇总"
date: 2016-08-08 08:27:00
categories: programming
excerpt: linux cmd的零碎积累
---

## find | xargs

找目录下所有文件总行数

`find . -type f | xargs wc -l`

## echo nameserver 8.8.8.8 >> /etc/resolv.conf

`>>` 是追加输出重定向，`>`是清空原文件的重定向。

`resolv.conf`是dns配置文件，配置文件通常放在`/etc`里，
`etc`就是and so on的那个etc，常用子目录有：

* `/etc/rc`, `/etc/rc.d`, `/etc/rc*.d` 启动、改变运行级时运行的scripts
* `/etc/passwd` 用户数据库
* `/etc/profile` 启动bash时执行的文件
* `/etc/inittab` 启动进程init的配置文件

注意`/etc/inittab`在debian, ubuntu中是没有的，只有`/etc/init`目录下的一坨，具体见这个文章：
[http://blog.csdn.net/heqiyu34/article/details/18793857](http://blog.csdn.net/heqiyu34/article/details/18793857)

## apt-get 安装到哪里了

一般是安装到`/usr/bin`，也有可能安装到`/usr/games`。
具体是谁决定的呢？ apt-get内部其实是下下来package及其依赖，安装过程是交给dpkg处理的。

直观的，我们可以运行`dpkg -L <package>`来看一个package的文件都放到了哪里。

## Shell Script

# 数组

```shell
array_name=(val1 val2 val3 ... valn)
echo ${array_name[0]} # read arr[0]
echo ${array_name[@]} # read arr[0...n]
echo ${#array_name[@]} # read arr length
```

# 传递参数

```shell
echo "executing file name: $0"
echo "#1 arg: $1"
echo "#2 arg: $2"
```

# expr

```shell
# 数字运算
val=`expr 2 + 2 \* 2`
echo "result is : $val"
val1=4
val2=6
if [ $val == $val1 ]
then
    echo "$val equals $val1"
fi

if [ $val -lt $val1 ]
then
    echo "$val less then $val1"
fi

if [ $val -lt $val1 -a $val -gt $val2]
then
    echo "$val less than $val1 and $val greater than $val2"
fi
# 字符串运算
str1="hahah"
str2="ttww"
if [ $str1 = $str2 ]
then
    echo "$str1 equal $str2"
fi
# 文件运算符
file="expr.sh"
if [ -r $file ]
then
   echo "文件可读"
fi
```

# if elif else

```shell
if [ $1 -gt $2 ]
then
    echo "$1 > $2"
elif [ $1 -lt $2 ]
then
    echo "$1 < $2"
else
    echo "$1 == $2"
fi
```

# while

```shell
while read film
do
    echo $film is good!
done
```

# case

```shell
echo input number 1~4
read num
case $num in
    1) echo you choose 1
    ;;
    2) echo you choose 2
    ;;
    *) echo you choose sth else
    ;;
esac
```

# function

```shell
add() {
    sum=0
    for i in $@
    do
        sum=`expr $sum + $i`
    done
    return $sum
}
add 1 2 3 4 5 6 7
echo $?
```

# 重定向

`command > file 2>&1` 标准输出和stderr都重定向到file

`command > /dev/null 2>&1` 标准输出和stderr都重定向到`/dev/null`，因为写入`/dev/null`的内容都会被丢弃，所以相当于禁用输出


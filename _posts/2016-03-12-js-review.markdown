---
layout: post
title: "js细节汇总"
date: 2016-03-12 08:27:00
categories: programming
---

## undefined

```javascript
if (aaa === undefined)
    //如果aaa是Undefined，会抛出ReferenceError!
```

```javascript
JSON.parse(undefined)
//抛异常unexpected token 'u'

JSON.parse({})
//抛异常unexpected token 'o'
```

## array
array.prototype.splice会删掉原数组内容！

## event
长按时，touchend事件不触发！
这是因为中间触发了touchmove事件，解决办法是touchmove的响应函数中调用`e.preventDefault()`即可。
错了！这是个bug！解决办法是touchstart中调用`e.preventDefault()`!

## $.fn.remove
今天遇到一个$.fn.remove失效的问题，暂时不知道什么原因，因为没有任何报错。
而且之前cached widget全部调用过一遍remove，需要仔细观察前一次的后果，然后分析。

## touch
今天看了下zepto的touch.js，swipe事件其实就是touchstart和touchend之间offset>30，就认为是swipe

## JSON
JSON.parse()如果参数已经是一个javascript object,  会抛unexpected token 'o'的异常

## querySelectorAll
返回是NodeList对象。
NodeList.length, NodeList.item(idx)。

NodeList里的值是Element对象。
这个属性比较多，还不熟悉。

## NaN

一个数除以0的结果是NaN

## defer 与 async

defer是说dom解析完后再去执行，顺序可以保证。
async是说dom解析完后再去执行，加载完立马执行，顺序无保证。

用defer发现要等app_cache里的内容，首屏是快了，js还是有点慢。
所以还是要用async，只要想办法确保顺序就行了。
由于我们用的是webpack打包过的，只有一个async文件，所以也是没有问题的。

## 事件代理

由于listener是加在父元素上的，所以e.stopPropagation()是没有用的。

## Int精度问题

js中，所有数字都是64位浮点数，所以最大精确到pow(2, 53) - 1 = 9007199254740991。

处理时，用big-integer库。

## TypeError: 没有isDefaultPrevented属性

分组管理focusout处理时遇到的，原因是trigger事件时，事件名称是空的

## 限流函数

有时我们不希望函数被频繁执行，而是希望其最多久执行一次，这时就需要"限流"

```javascript
/* @func: 输入一个func，返回的函数最短wait时间调用一次，最长mustRun时间调用一次
 * @params:
 *      func{Function}
 *      wait{int}: wait in ms
 *      mustRun{int}: mustRun in ms
 */
function throttle (func, wait, mustRun) {
    var timeout,
        startTime = new Date();

    return function () {
        var context = this,
            args = arguments,
            curTime = new Date();

        window.clearTimeout(timeout);

        if (curTime - startTime > mustRun) {
            func.apply(context, args);
        } else {
            window.setTimeout(func, wait);
        }
    };
}
```

## canvas

`canvas.width`相当于svg的viewBox，画布大小。
为了canvas在高分辨率屏幕上不模糊，采用css宽高100%，画布宽高乘以dpr的做法。

## Array.map部分不返回

貌似没有办法，只能.filter().map()这样组合实现。

## $.ajax跨域

1.a.com和2.a.com是不同的host，数据能取到，但因为Header里
`Access-Control-Allow-Origin: http://qzs.qq.com`

这里内容有点多，详见[mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)

## 空字符串

这个涉及到类型转换，js期望使用字符串，会把对象类型转为字符串，如 n + 'aa'的情况。
js期望使用数字，会把非数字转为数字，如 '7' * '4' 的情况。
js期望使用布尔，会自动转bool，如 if () 的情况。

对字符串来说，空字符串转化为：

* 数字： 0
* 布尔： false

## $.on $.one

用on的话，会增量的加事件监听，在redux这种反复subscribe的情景下，很容易出bug。
因此，用one是很好的选择。

来看看.one是如何实现的:

```javascript
// one
$.fn.one = function(event, selector, data, callback) {
    return this.on(event, selector, data, callback, 1)
}
// one -> on
$.fn.on = function(event, selector, data, callback, one){
   ...
   return $this.each(function(_, element) {
      if (one) autoRemove = function(e){
         remove(element, e.type, callback)
         return callback.apply(this, arguments)
      }
      add(element, event, callback, data, selector, delegator || autoRemove)
      ...
   }
}
// on -> add
function add(element, events, fn, data, selector, delegator, capture){
    handler.del   = delegator
    element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
    
function eventCapture(handler, captureSetting) {
    return handler.del &&
      (!focusinSupported && (handler.e in focus)) ||
      !!captureSetting
}

}
```

另一个问题是，.off是否会把所有.on添加的listener都删除掉？
答案是能删掉，来看看实现吧：


## $.data

我们知道，$.data可以存任意object，这是如何实现的？

```javascript
var data = {}, dataAttr = $.fn.data, camelize = $.camelCase,
    exp = $.expando = 'Zepto' + (+new Date()), emptyArray = [];
  
// Store value under camelized key on node
function setData(node, name, value) {
    var id = node[exp] || (node[exp] = ++$.uuid),
      store = data[id] || (data[id] = attributeData(node))
    if (name !== undefined) store[camelize(name)] = value
    return store
}
```

存到内存里的一个变量data = {}里啦！ id由`$.uuid`生成，当然任意咯。
---
layout: post
title: "全面拥抱es2015: 从页面，后台到测试"
date: 2016-07-01 08:27:00
categories: programming
---

# es6 测试

expect库是一个有力的测试工具，我们期望如下代码能够node test.js以下就能跑起来：

```javascript
import expect from 'expect';
import {byteToIntArr} from './protobuf';

const byteArr = {
    '0': 8, '1': 48, '3': 0
    };

expect(
    byteToIntArr(byteArr)
    ).toEqual(48);

console.log('Tests passed!');
```

然而，直接node运行es6代码会报报错'unexpected reseed word import', 该如何让这段测试用例跑起来呢？
答案是babel-cli。

安装之后，运行`babel-node --presets es2015 test.js`.
至于为什么一定要--presets，有空再说，先上车！

# Object.assign

Object.assign(target, ...sources)

把多个源的可枚举属性copy到目标对象上去。
redux里用于在不改变原state的情况下，在reducer里返回新的state。

但为什么要这么做？

> Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.

简单的说，纯函数可以毫无顾忌的去组合，而不用担心副作用。
其他几条还需要在实践中体会。

实际使用中, Object.assign会报错undefined is not a function.
这是因为babel-loader只转es6语法，不转es6标准库。

解决方法有两种，
一是`import babel-polyfill`，但这个很大，不压缩有200k。
二是$.extend，功能是一样的，推荐。

# $.extend的实现

先到这里顺便写下$.extend的实现，基本思想就是递归向下，直到遇到基础类型。

代码如下：

```javascript
  function extend(target, source, deep) {
    for (key in source)
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          target[key] = {}
        if (isArray(source[key]) && !isArray(target[key]))
          target[key] = []
        extend(target[key], source[key], deep)
      }
      else if (source[key] !== undefined) target[key] = source[key]
  }
```

非深拷贝没什么好讲的，直接key覆盖。
深拷贝需要递归到底，因为基础类型不是引用的，所以=就是深拷贝。

这里另一个要注意的地方是，isPlainObj(obj)，则obj的复制是引用复制。
具体来讲：

```
  function isObject(obj)     { return type(obj) == "object" }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
  }
```

# Async Action

什么是异步动作？简单的说，我希望在这个瞬间dispatch(actionA), 然而actionA实际要经历网络请求，
真正的action对象要在未来某个时间点才会抛出来。

要实现这个功能，不用middleWare的话，应该这样写：

```javascript
$.ajax('aa.com/post/a', {
    success: function(data) {
        store.dispatch({
            type: 'actionA',
            data: data
        })
    }
});
```

这样显然是冗余代码，可以这样thunk一下：

```javascript
function asyncActionA() {
    return function(dispatch) {
        dispatch({action: 'BEGIN_REQUEST'});
        return fetch('aa.com/post/a')
               .then(response => response.json())
               .then(json => dispatch({type: 'END_REQUEST', data: json)
    }
    
}
```

thunk的意思就是把执行推后，这样就可以在瞬时这样调用了：

```javascript
store.dispatch(asyncActionA());
```


<!DOCTYPE html>
<html>
  	<head>
  		<title>VictorIsildur's Blog</title>
  		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
  		<meta name="description" content="" />
  		<meta name="keywords" content="" />
  		<!--[if lte IE 8]><script src="css/ie/html5shiv.js"></script><![endif]-->
  		<script src="/js/jquery.min.js"></script>
  		<script src="/js/jquery.poptrox.min.js"></script>
  		<script src="/js/skel.min.js"></script>
  		<script src="/js/init.js"></script>
  		<noscript>
  			<link rel="stylesheet" href="/css/skel.css" />
  			<link rel="stylesheet" href="/css/style.css" />
  			<link rel="stylesheet" href="/css/style-xlarge.css" />
  		</noscript>
  		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie/v8.css" /><![endif]-->
  	</head>

	<body id="top">

      <header id="header">
          <a href="#" class="image avatar"><img src="/images/aragon.jpg" alt="" /></a>
          <h1><strong>I am <a href="https://github.com/victorisildur">VictorIsildur</a></strong>. First a programmer<br />
          Then a web coder<br />
      </header>


        <div id="main">
    <article>
        <header class="major">
            <h2 class="post-title">unix环境高级编程4: 设备控制与事件驱动编程</h2>
                <p class="post-meta">Nov 11, 2015</p>
        </header>

        <section>
            <p>看完了普通文件系统，接下来看设备。</p>

<h2 id="section">终端是什么</h2>

<p><code class="highlighter-rouge">ls /dev</code>一下，最后一列是中断，ttysd, ttyse等都代表中断。
很多用户输入都来自终端。传统中断是键盘和显示单元。
但telnet或ssh窗口也可以认为是一个终端。</p>

<p>#磁盘连接的属性</p>

<p>系统调用open用于在进程和磁盘文件之间创建一个连接。
磁盘链接有两个特殊属性：缓冲、自动添加模式。</p>

<p>系统调用open用于在进程和磁盘文件之间创建一个连接。
进程和中断间的连接看起来很简单。
用<code class="highlighter-rouge">getchar()</code>和<code class="highlighter-rouge">putchar()</code>就能在终端和进程间传输字节。</p>

<p>然而，实际上这个模型是不完整的。
<code class="highlighter-rouge">getchar()</code>在输入回车之后才会有反应。
这说明设备文件描述符和进程之间必定有一个处理层：</p>

<ol>
  <li>进程在用户输入return后才接收数据</li>
  <li>进程将用户输入的return看做换行符</li>
  <li>进程发送换行符，终端接收到回车+换行</li>
</ol>

<p>这中间夹的一层叫做终端驱动程序或tty驱动程序（tty是指teletype公司的老式打印终端）。
还记得我们的more程序吗？我们用<code class="highlighter-rouge">tcsetattr()</code>设置了<code class="highlighter-rouge">termios-&gt;c_lflags</code>里的一些位。</p>

<p><code class="highlighter-rouge">stty</code>就是查看中断驱动程序的命令。发现了什么？里面有lflags内容！
tty驱动程序包含很多对传入数据所进行的操作，分为4类：</p>

<ol>
  <li>输入：驱动如何处理从终端来的字符</li>
  <li>输出：驱动如何处理流向终端的字符</li>
  <li>控制：字符如何被表示：位的个数、位的奇偶性、停止位</li>
  <li>本地：驱动如何处理来自驱动内部的字符</li>
</ol>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">termios</span> <span class="n">org_opts</span><span class="p">,</span> <span class="n">new_opts</span><span class="p">;</span>
<span class="n">tcgetattr</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">org_opts</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_opts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">org_opts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_opts</span><span class="p">));</span>
<span class="n">new_opts</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ICANON</span> <span class="o">|</span> <span class="n">ECHO</span><span class="p">);</span>         <span class="c1">// c_lflag: control mode flags
</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_opts</span><span class="p">);</span>  <span class="c1">// TCSANOW: 立即更新驱动程序设置
</span></code></pre>
</div>

<p>so, 到不同设备的连接，属性集不同。
磁盘连接的属性则是诸如O_SYNC, O_APPEND这样的属性。
程序员如何查看和控制一个设备的设置呢？</p>

<p>系统调用ioctl提供对连接到fd的设备驱动的属性和操作的访问。
每种类型的设备都有自己的属性集合ioctl操作集。
我们试试用ioctl显示屏幕的尺寸：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;sys/ioctl.h&gt;
</span><span class="kt">void</span> <span class="nf">print_screen_dimensions</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">winsize</span> <span class="n">wbuf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ioctl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">TIOCGWINSZ</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>   
    <span class="cm">/* TIOCGWINSZ是request代号。
     * 定义在sys/ioctl.h中。
     */</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d rows x %d cols</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">.</span><span class="n">ws_row</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">.</span><span class="n">ws_col</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d wide x %d tall</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">.</span><span class="n">ws_xpixel</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">.</span><span class="n">ws_ypixel</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="section-1">为用户编程：终端控制和信号</h2>

<p>用户应该如何应对signal? 我们看个例子就知：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;signal.h&gt;
</span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Ouch!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>忽略信号呢？<code class="highlighter-rouge">signal(SIGINT, SIG_IGN)</code>就好！
unix中信号有16种，都在<code class="highlighter-rouge">signal.h</code>中定义。KILL,QUIT,INT等都有。</p>

<h2 id="section-2">事件驱动编程</h2>

<h1 id="pong">pong</h1>

<p>就是用一个挡板反弹小球，小时候比诺基亚更早的时代，手机上往往有这个游戏。
（我你妹学unix就是越学月回去的过程。。。）</p>

<p>图形上，我们就在tty上做，25*80，呵呵，激动吧。这其实是有库的，叫curses。
其主要函数有move,addstr,addch,clear,standout,standend.</p>

<p>其实就是每秒变换位置画string，例子在这里：<a href="https://github.com/victorisildur/UNIX/blob/master/APUE/game/pong_str.c">pong string game</a></p>

<p>这个简单地例子只能1s刷新一次，这是<code class="highlighter-rouge">sleep()</code>带来的限制。
我们需要更精确的时间控制：alarms。
sleep的内部是由alarm做的，其步骤为：</p>

<ol>
  <li>为SIGALRM设置一个处理函数</li>
  <li>调用<code class="highlighter-rouge">alarm(num_seconds)</code></li>
  <li>调用<code class="highlighter-rouge">pause</code>，这个sys call挂起进程，直到信号到达。注意是任何信号。</li>
</ol>

<p>额，其实这个只是解释了下sleep的内部，精度1s的问题还是没有解决。
后来，unix退出interval timer的概念，有更高的精度。
每个进程都有3个独立的计时器，而不是原来的一个。
计时器有两个设置：初始间隔、重复间隔。
函数为nsleep，单位是微秒。</p>

<p>三种计时器分别是：</p>

<ol>
  <li>ITIMER_REAL. 不管核心态还是用户态用了多少处理器时间，它都记录。
当它定时时间到，发送SIGALRM信号。</li>
  <li>ITIMER_VIRTUAL. 只记录用户态运行时。
发送SIGVTALRM信号。</li>
  <li>ITIMER_PROF
发送SIFPROF信号。</li>
</ol>

<p>间隔计时器的例子见这里：<a href="https://github.com/victorisildur/UNIX/blob/master/APUE/game/ticker_demo.c">ticker demo</a></p>

<p>第二个问题是多种信号同时到来会怎样？堵塞？排队？还是忽略？
我们可以通过例程看一下：<a href="">multi signal demo</a></p>

<p>我们可以得出结论：</p>

<ol>
  <li>处理函数不用每次重置。
处理函数被调用后仍起作用。我们设置一次处理函数就行了。</li>
  <li>后来的信号会打断前面的信号。
连续按<code class="highlighter-rouge">ctrl+c</code>和<code class="highlighter-rouge">ctrl+\</code>，会发现inthandler之后紧接着quithandler，然后回到Inthandler，最后回到main</li>
  <li>SIGX阻塞SIGX。连续按两次<code class="highlighter-rouge">ctrl+c</code>，会发现第二次会被阻塞住。
如果疯狂地按，有些被阻塞的SIGX会被忽略。</li>
  <li>被中断的syscall。
如果我们正在read的时候，按下<code class="highlighter-rouge">ctrl+c</code>会怎样？
amazing! 之前输入的字符没有了！</li>
</ol>

<p>so,还是挺多细节的。不好搞啊。</p>

<p>POSIX搞了个改进版的信号库，以应对多信号时的种种竞争情况。
我们从其设置信号handler的结构器看看它有哪些东西：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span>  <span class="n">sigaction</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">__sigaction_u</span> <span class="n">__sigaction_u</span><span class="p">;</span>  <span class="cm">/* signal handler */</span>
    <span class="n">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span>               <span class="cm">/* signal mask to apply */</span>
    <span class="kt">int</span>     <span class="n">sa_flags</span><span class="p">;</span>               <span class="cm">/* see signal options below */</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">__sigaction_u</span> <span class="p">{</span>
    <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">__sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>    <span class="cm">/* SIG_DFL, SIG_IGN, or function*/</span>
    <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">__sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/*new handler*/</span>
<span class="p">};</span>
</code></pre>
</div>

<p>可以看到，<code class="highlighter-rouge">__sa_sigaction()</code>参数有<code class="highlighter-rouge">__siginfo</code>，它就给了我们关于信号更多一些的信息。
如何告诉内核我们要用新的信号处理方式呢？设置<code class="highlighter-rouge">sa_flags</code>的<code class="highlighter-rouge">SA_SIGINFO</code>位就行了。
至于sa_mask和sa_flags，设置比较简单：</p>

<ol>
  <li>sa_flags有四个位：SA_RESETHAND设置是否“捕鼠器”模式。
SA_NODEFER。是否关闭信号自动阻塞。
SA_RESTART。不太明白。
SA_SIGINFO。指明用sa_handler韩式sa_sigaction</li>
  <li>sa_mask: 决定是否阻塞其他信号。</li>
</ol>

<p>例子很简单，我们赶时间，就不写了。</p>

<h1 id="section-3">临界区问题</h1>

<p>想写个游戏的前置问题真是多啊。。</p>

<p>一段代码，如果在运行时被打断讲导致数据的损毁，则称这段代码为临界区。
想要保护临界区？阻塞信号就好！
代码如下：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">sigset_t</span> <span class="n">sigs</span><span class="p">,</span> <span class="n">prevsigs</span><span class="p">;</span>
<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigs</span><span class="p">);</span>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigs</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigs</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">);</span>
<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prevsigs</span><span class="p">);</span>
<span class="cm">/*阻塞了，可以操作临界区了*/</span>
<span class="c1">//blabla...
</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SET</span><span class="p">,</span> <span class="o">*</span><span class="n">prevsigs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre>
</div>

<p>我们的挡板游戏中有什么临界区呢？</p>

<p>代码如下：<a href="https://github.com/victorisildur/UNIX/blob/master/APUE/game/bounce1d.c">1d bounce game</a></p>

        </section>
        
        <footer>
            <div class="row">
            
            
                <article class="6u 12u(small) excerpt">
                    <header>
                        <h2><a href="/os/2015/11/10/apue-ls.html">unix环境高级编程3: ls</a></h2>
                    </header>
                    <section>
                        <p>apue编程实践一共有15章，后面的章节涉及事件编程、线程、网络。
必须快点看了，一天2章。出去玩之前搞定：</p>


                    </section>
                    <footer>
                        <ul class="actions">
                            <li><a href="/os/2015/11/10/apue-ls.html" class="button">Read More</a></li>
                        </ul>
                    </footer>
                </article>
            
            
            
            
                <article class="6u$ 12u(small) excerpt f-right">
                    <header>
                        <h2><a href="/os/2015/11/16/apue-process.html">unix环境高级编程5: 进程</a></h2>
                    </header>
                    <section>
                        <h2 id="shell">shell是如何实现的？</h2>


                    </section>
                    <footer>
                        <ul class="actions">
                            <li><a href="/os/2015/11/16/apue-process.html" class="button">Read More</a></li>
                        </ul>
                    </footer>
                </article>
            
            </div>
        </footer>

    </article>

</div>


        <!-- Footer -->
        <footer id="footer">
            <ul class="icons">

              
              <li>
                <a href="https://github.com/victorisildur" class="icon fa-github">
                  <span class="label">GitHub</span>
                </a>
              </li>
              

              
              <li>
                <a href="https://twitter.com/victorisildur" class="icon fa-twitter">
                  <span class="label">Twitter</span>
                </a>
              </li>
              

              
              <li>
                <a href="https://linkedin.com/in/刘旭" class="icon fa-linkedin">
                  <span class="label">LinkedIn</span>
                </a>
              </li>
              

              

              

              

              
              <li>
                <a href="mailto:isi_liuxu@yeah.net" class="icon fa-envelope-o">
                  <span class="label">Email</span>
                </a>
              </li>
              
            </ul>
            <ul class="copyright">
                <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
                <li>Demo Images: <a href="https://unsplash.com/">Unsplash</a></li>
                <li>Jekyll Template: <a href="http://cloudcannon.com">Cloud Cannon</a></li>
            </ul>
        </footer>

	</body>
</html>
